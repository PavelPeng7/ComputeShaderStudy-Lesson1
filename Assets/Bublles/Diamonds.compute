// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Circles
#pragma kernel Clear

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
shared RWTexture2D<float4> Result;

struct circle
{
	float2 origin;
	float2 velocity;
	float radius;
};

StructuredBuffer<circle> circlesBuffer;

float4 clearColor;
float4 circleColor;
int texResolution;
int clearScreen = 0;
float time;

/*Returns pseudo random number in range 0 <= x < 1 */
float random(float value, float seed = 0.546){
	float random = (frac(sin(value + seed) * 143758.5453));// + 1.0)/2.0;
	return random;
}

float2 random2(float value){
	return float2(
		random(value, 3.9812),
		random(value, 7.1536)
	);
}

void drawDiamond(int2 center, int size) {
	for (int y = -size; y <= size; y++) {
		int span = size - abs(y);
		for (int x = -span; x <= span; x++) {
			Result[uint2(center.x + x, center.y + y)] = circleColor;
		}
	}
}

void drawDiamondRepeat(int2 center, int size)
{
	for (int y = -size; y <= size; y++) {
		int span = size - abs(y);
		for (int x = -span; x <= span; x++) {
			int2 pos = center + int2(x, y);

			// Wrap around (tile the image)
			pos.x = (pos.x % texResolution + texResolution) % texResolution;
			pos.y = (pos.y % texResolution + texResolution) % texResolution;

			Result[uint2(pos)] = circleColor;
		}
	}
}

[numthreads(32,1,1)]
void Circles (uint3 id : SV_DispatchThreadID)
{
	int2 center = (int2)(circlesBuffer[id.x].origin + circlesBuffer[id.x].velocity * time);
	while (center.x>texResolution) center.x -= texResolution;
	while (center.x<0) center.x += texResolution;
	while (center.y>texResolution) center.y -= texResolution;
	while (center.y<0) center.y += texResolution;
	
	uint radius = (int)circlesBuffer[id.x].radius;

	drawDiamondRepeat( center, radius );
}

[numthreads(8,8,1)]
void Clear (uint3 id : SV_DispatchThreadID)
{
	Result[id.xy] = clearColor;
}




